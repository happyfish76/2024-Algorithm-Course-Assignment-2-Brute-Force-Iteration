# 算法理论作业2： 蛮力迭代

在计算机科学的领域中，蛮力迭代是一种基础且有效的方法，它通过穷举所有可能的解决方案来解决问题。这种方法虽然可能在效率上不及其他高级算法，但其简单直接的特性使其在许多情况下仍然非常有用。以下是对穷举法和迭代法的简单总结以及具体实现。

## 1.穷举法

### （1）线性穷举

线性穷举是一种简单而直接的方法，它按顺序检查所有可能的解决方案，直到找到满足条件的解。这种方法在问题空间较小且解决方案的数量可预测时尤其有效。例如，在寻找一个整数的因子时，我们可以从1开始逐个检查直到找到所有的因子。

以下为使用线性穷举实现查找最大值最小值的代码：

```c
#include <stdio.h>
#define SIZE 10
void findMinMax(int array[], int size, int *min, int *max);
int main() {
    // 初始化数组
    int array[SIZE] = {5, 2, 8, 10, 1, 7, 3, 9, 4, 6};    
    // 输出数组
    printf("数组内容：\n");
    for (int i = 0; i < SIZE; i++) {
        printf("%d ", array[i]);
    }
    printf("\n");    
    // 用于存储最小值和最大值
    int min, max;    
    // 调用函数查找最小值和最大值
    findMinMax(array, SIZE, &min, &max);    
    // 输出结果
    printf("最小值：%d\n", min);
    printf("最大值：%d\n", max);    
    return 0;
}

// 函数定义：查找最小值和最大值
void findMinMax(int array[], int size, int *min, int *max) {
    // 假设数组中第一个元素为最小值和最大值
    *min = *max = array[0];    
    // 循环遍历数组，更新最小值和最大值
    for (int i = 1; i < size; i++) {
        if (array[i] < *min) {
            *min = array[i];
        }
        if (array[i] > *max) {
            *max = array[i];
        }
    }
}

```

运行结果如下：![image-20240512143726836](C:\Users\22270\AppData\Roaming\Typora\typora-user-images\image-20240512143726836.png)

### （2）树形穷举

树形穷举通过树状结构系统地枚举所有可能的解决方案。它将问题分解为一系列子问题，并递归地处理每个子问题，直到达到最终解。这种方法在问题的解决方案具有层级结构时非常有用。例如，在求解旅行商问题时，可以通过树形结构穷举所有可能的路径。

N皇后问题：将n个皇后放置在n*n的棋盘上，皇后彼 此之间不能相互攻击(任意两个皇后不能位于同一行， 同一列，同一斜线)

```c
#include <stdio.h>
#include <stdlib.h>
#define N 4
int board[N]; // 存储皇后所在列的索引
// 检查在第row行，第col列放置皇后是否合法
int isSafe(int row, int col) {
    int i;
    // 检查当前列是否已经放置了皇后
    for (i = 0; i < row; i++) {
        if (board[i] == col || abs(i - row) == abs(board[i] - col))
            return 0;
    }
    return 1;
}
// 在第row行放置皇后
void placeQueen(int row) {
    int col;
    // 如果所有行都处理完了，打印解决方案
    if (row == N) {
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (board[i] == j)
                    printf("Q ");
                else
                    printf(". ");
            }
            printf("\n");
        }
        printf("\n");
    } else {
        // 在当前行尝试每一列放置皇后
        for (col = 0; col < N; col++) {
            // 检查当前位置是否合法
            if (isSafe(row, col)) {
                board[row] = col; // 放置皇后
                // 递归处理下一行
                placeQueen(row + 1);
            }
        }
    }
}
int main() {
    // 初始化棋盘
    for (int i = 0; i < N; i++) {
        board[i] = -1; // 初始时没有皇后放置在棋盘上
    }
    // 开始在第0行放置皇后
    placeQueen(0);
    return 0;
}
```

运行结果如下：

![image-20240512144323999](C:\Users\22270\AppData\Roaming\Typora\typora-user-images\image-20240512144323999.png)

## 2.迭代法

### （1）简单迭代

简单迭代是一种基本的迭代方法，它通过反复应用一个简单的操作来逐步接近解决方案。这种方法通常用于求解数值问题，如求方程的根或求函数的极值点。例如，通过不断逼近函数的零点，可以使用简单迭代方法求解方程的解。

#### 线性查找

##### 顺序查找

```c
#include <stdio.h>
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target)
            return i; // 如果找到目标，则返回其索引
    }
    return -1; // 如果未找到目标，则返回-1
}
int main() {
    int arr[] = {2, 5, 7, 9, 12, 15, 17};
    int n = sizeof(arr) / sizeof(arr[0]); // 数组的大小
    int target = 12; // 要查找的目标
    int index = linearSearch(arr, n, target);
    if (index != -1) {
        printf("目标 %d 在数组中的索引为: %d\n", target, index);
    } else {
        printf("目标 %d 不在数组中\n", target);
    }
    return 0;
}
```
